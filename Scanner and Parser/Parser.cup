import java_cup.runtime.*;
import java.io.Reader;

/* Código inicial */
parser code {:
    // Conectar el parser con el scanner
    Scanner scanner;

    /** Constructor del Parser que recibe un Scanner. */
    public Parser(Scanner scanner) {
        super(scanner); // Llama al constructor de java_cup.runtime.lr_parser
        this.scanner = scanner;
    }

    /**
     * Método MEJORADO para el manejo de los errores de sintaxis.
     */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("[Error de Sintaxis]");
        
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            
            // <-- CAMBIO: El scanner (yyline + 1) ya suma 1. No sumar de nuevo.
            if (s.left >= 1) { // s.left es la línea
                m.append(" en línea " + s.left);
                if (s.right >= 1) { // s.right es la columna
                    m.append(", columna " + s.right);
                }
            }

            if (s.sym != sym.EOF) {
                m.append(". Se encontró un token inesperado: '" + s.value + "' (Tipo: " + sym.terminalNames[s.sym] + ")");
            } else {
                m.append(". Se llegó al fin de archivo inesperadamente.");
            }
        }
        
        m.append("\n  > " + message.replace("\n", "\n  > "));
        System.err.println(m);
    }

    /**
     * Método para reportar errores fatales 
     */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Error fatal de sintaxis. No se puede continuar.");
    }

    /**
     * Método principal para iniciar el análisis
     */
    public Symbol do_parse() throws Exception {
        return this.parse();
    }
:};

/* --- Declaraciones de Terminales (Tokens) --- */
terminal PROGRAM, MAIN, END, VAR, INT, FLOAT, VOID, IF, ELSE, WHILE, DO, PRINT;
terminal ASSIGN, PLUS, MINUS, TIMES, DIV, GT, LT, NE;
terminal SEMI, COMMA, COLON, LPAREN, RPAREN, LBRACE, RBRACE;
// 'error' es implícito, no se declara.
terminal UPLUS, UMINUS;
terminal String ID, CTE_STRING;
terminal Integer CTE_INT;
terminal Float CTE_FLOAT;

/* --- Declaraciones de No-Terminales --- */
non terminal programa, vars, lista_vars, declaracion, lista_ids, type;
non terminal funcs, def_func, tipo_retorno, params, lista_params;
non terminal required_body, optional_body, lista_sentencias, sentencia;
non terminal assign, print, lista_print, elemento_print, cycle, condition, else_part;
non terminal expresion, exp, op_relacional, termino, factor, cte, f_call, argumentos, lista_argumentos;

/* --- Precedencia y Asociatividad --- */
precedence left GT, LT, NE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right UPLUS, UMINUS; 

/* --- La Gramática --- */

start with programa;

/* Estructura General del Programa */
programa ::= PROGRAM ID SEMI vars funcs MAIN required_body END
    {: System.out.println("Análisis sintáctico completado con éxito."); :};

/* Declaración de Variables */
vars ::= VAR lista_vars
       | /* epsilon */
       ;

lista_vars ::= lista_vars declaracion
             | declaracion
             ;

declaracion ::= lista_ids COLON type SEMI
            // Mantenemos la recuperación aquí
            | error SEMI 
                {: parser.report_error("Error en declaración, recuperando en ';'", null); :}
            ;

lista_ids ::= lista_ids COMMA ID
            | ID
            ;

type ::= INT | FLOAT;

/* Definición de Funciones */
funcs ::= funcs def_func
        | /* epsilon */
        ;

// <-- CAMBIO: Se eliminó la regla '| error SEMI' de aquí para resolver el conflicto
def_func ::= tipo_retorno ID LPAREN params RPAREN vars optional_body SEMI;

tipo_retorno ::= VOID | type;

params ::= lista_params
         | /* epsilon */
         ;

lista_params ::= lista_params COMMA ID COLON type
               | ID COLON type
               ;

/* Cuerpo y Sentencias (Usando la corrección anterior para el conflicto S/R) */

required_body ::= LBRACE RBRACE // Cuerpo vacío
                | LBRACE lista_sentencias RBRACE
                ;

optional_body ::= LBRACE RBRACE // Cuerpo vacío
                | LBRACE lista_sentencias RBRACE
                | /* epsilon */ // Sin cuerpo
                ;

lista_sentencias ::= lista_sentencias sentencia
                   | sentencia // Debe tener al menos una
                   ;

sentencia ::= assign
            | condition
            | cycle
            | f_call SEMI
            | print
            // Recuperación de sentencia
            | error SEMI 
                {: parser.report_error("Error de sintaxis en sentencia, recuperando en ';'", null); :}
            ;

/* Definición de las Sentencias */
assign ::= ID ASSIGN expresion SEMI;
print ::= PRINT LPAREN lista_print RPAREN SEMI;
lista_print ::= lista_print COMMA elemento_print | elemento_print;
elemento_print ::= expresion | CTE_STRING;
cycle ::= WHILE LPAREN expresion RPAREN DO required_body SEMI;
condition ::= IF LPAREN expresion RPAREN required_body else_part SEMI;
else_part ::= ELSE required_body | /* epsilon */ ;

/* Jerarquía de Expresiones */
expresion ::= exp op_relacional exp | exp;
op_relacional ::= GT | LT | NE;
exp ::= exp PLUS termino | exp MINUS termino | termino;
termino ::= termino TIMES factor | termino DIV factor | factor;
factor ::= LPAREN expresion RPAREN
         | PLUS factor %prec UPLUS
         | MINUS factor %prec UMINUS
         | cte
         | f_call
         | ID
         ;
cte ::= CTE_INT | CTE_FLOAT;
f_call ::= ID LPAREN argumentos RPAREN;
argumentos ::= lista_argumentos | /* epsilon */ ;
lista_argumentos ::= lista_argumentos COMMA expresion | expresion;