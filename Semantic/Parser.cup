import java_cup.runtime.*;
import java.io.Reader;

/* ================================
   BLOQUE DE CÓDIGO INICIAL
   ================================ */
parser code {:
    public semantico.FuncDir funcDir = new semantico.FuncDir();
    public semantico.CuboSemantico cubo = new semantico.CuboSemantico();
    public String currentFunction = "global";
    Scanner scanner;
    public boolean syntaxError = false;

    public Parser(Scanner scanner) {
        super(scanner);
        this.scanner = scanner;
    }

    public void report_error(String message, Object info) {
        this.syntaxError = true;
        System.err.println("[Error de Sintaxis] " + message);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Error fatal de sintaxis.");
    }

    public Symbol do_parse() throws Exception { return this.parse(); }
:};

/* ================================
   TERMINALES
   ================================ */
terminal PROGRAM, MAIN, END, VAR, INT, FLOAT, VOID, IF, ELSE, WHILE, DO, PRINT;
terminal ASSIGN, PLUS, MINUS, TIMES, DIV, GT, LT, NE;
terminal SEMI, COMMA, COLON, LPAREN, RPAREN, LBRACE, RBRACE;
terminal UPLUS, UMINUS;
terminal String ID, CTE_STRING;
terminal Integer CTE_INT;
terminal Float CTE_FLOAT;

/* ================================
   NO TERMINALES
   ================================ */
non terminal programa, vars, lista_vars, declaracion;
non terminal java.util.ArrayList<String> lista_ids;
non terminal String type;
non terminal funcs, def_func, tipo_retorno, params, lista_params;
non terminal required_body, optional_body, lista_sentencias, sentencia;
non terminal assign, print, lista_print, elemento_print, cycle, condition, else_part;
non terminal String expresion, exp, termino, factor, cte, op_relacional;
non terminal f_call, argumentos, lista_argumentos;

/* ================================
   PRECEDENCIA
   ================================ */
precedence left GT, LT, NE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right UPLUS, UMINUS;

/* ================================
   GRAMÁTICA
   ================================ */
start with programa;

/* PROGRAMA */
programa ::= PROGRAM ID SEMI
    {: funcDir.addFunction("global", "void"); :}
    vars funcs MAIN required_body END
    {:
        System.out.println("Análisis sintáctico completado con éxito.");
        System.out.println("\n===== Estado Semántico =====");
        funcDir.printDir();
    :};

/* VARIABLES */
vars ::= VAR lista_vars
       | /* epsilon */
       ;

lista_vars ::= lista_vars declaracion
             | declaracion
             ;

declaracion ::= lista_ids:ids COLON type:t SEMI
    {:
        for (String id : ids) {
            funcDir.getVarTable(currentFunction).addVariable(id, t);
        }
    :}
  | error SEMI {: System.err.println("[Recuperación] Error en declaración."); :}
  ;

/* LISTA DE IDS */
lista_ids ::= lista_ids:l COMMA ID:id
    {:
        l.add(id);
        RESULT = l;
    :}
  | ID:id
    {:
        java.util.ArrayList<String> nueva = new java.util.ArrayList<>();
        nueva.add(id);
        RESULT = nueva;
    :}
  ;

/* TIPOS */
type ::= INT   {: RESULT = "int"; :}
      | FLOAT {: RESULT = "float"; :}
      ;

/* FUNCIONES */
funcs ::= funcs def_func
        | /* epsilon */
        ;
def_func ::= tipo_retorno ID LPAREN params RPAREN vars optional_body SEMI;
tipo_retorno ::= VOID | type;
params ::= lista_params | /* epsilon */ ;
lista_params ::= lista_params COMMA ID COLON type | ID COLON type;

/* CUERPOS */
required_body ::= LBRACE RBRACE | LBRACE lista_sentencias RBRACE;
optional_body ::= LBRACE RBRACE | LBRACE lista_sentencias RBRACE | /* epsilon */ ;
lista_sentencias ::= lista_sentencias sentencia | sentencia;

/* SENTENCIAS */
sentencia ::= assign
            | condition
            | cycle
            | f_call SEMI
            | print
            | error SEMI {: System.err.println("[Recuperación] Error en sentencia."); :}
            ;

/* ASIGNACIÓN */
assign ::= ID:id ASSIGN expresion:expr SEMI
    {:
        semantico.VarInfo v = funcDir.lookupVariable(id, currentFunction);
        if (v == null)
            System.err.println("[Error semántico] Variable '" + id + "' no declarada.");
        else {
            String res = cubo.checkAssignment(v.getTipo(), expr);
            if (res.equals("ERROR"))
                System.err.println("[Error semántico] Asignación incompatible: " + v.getTipo() + " = " + expr);
        }
    :};

/* PRINT / CONTROL */
print ::= PRINT LPAREN lista_print RPAREN SEMI;
lista_print ::= lista_print COMMA elemento_print | elemento_print;
elemento_print ::= expresion | CTE_STRING;
cycle ::= WHILE LPAREN expresion RPAREN DO required_body SEMI;
condition ::= IF LPAREN expresion RPAREN required_body else_part SEMI;
else_part ::= ELSE required_body | /* epsilon */ ;

/* EXPRESIONES */
expresion ::= exp:e1 op_relacional:op exp:e2
    {: RESULT = cubo.checkOperation(op, e1, e2); :}
  | exp:e {: RESULT = e; :}
  ;

op_relacional ::= GT {: RESULT = ">"; :}
                | LT {: RESULT = "<"; :}
                | NE {: RESULT = "!="; :}
                ;

exp ::= exp:e1 PLUS termino:e2
    {: RESULT = cubo.checkOperation("+", e1, e2); :}
  | exp:e1 MINUS termino:e2
    {: RESULT = cubo.checkOperation("-", e1, e2); :}
  | termino:e {: RESULT = e; :}
  ;

termino ::= termino:t1 TIMES factor:t2
    {: RESULT = cubo.checkOperation("*", t1, t2); :}
  | termino:t1 DIV factor:t2
    {: RESULT = cubo.checkOperation("/", t1, t2); :}
  | factor:f {: RESULT = f; :}
  ;

factor ::= LPAREN expresion:e RPAREN {: RESULT = e; :}
         | cte:c {: RESULT = c; :}
         | ID:id
            {:
                semantico.VarInfo v = funcDir.lookupVariable(id, currentFunction);
                if (v == null) RESULT = "ERROR";
                else RESULT = v.getTipo();
            :}
         ;

cte ::= CTE_INT {: RESULT = "int"; :}
     | CTE_FLOAT {: RESULT = "float"; :}
     ;

f_call ::= ID LPAREN argumentos RPAREN;
argumentos ::= lista_argumentos | /* epsilon */ ;
lista_argumentos ::= lista_argumentos COMMA expresion | expresion;